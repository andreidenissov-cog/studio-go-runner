// Copyright 2020-2021 (c) Cognizant Digital Business, Evolutionary AI. All rights reserved. Issued under the Apache 2.0 License.

package main

// This file contains testing functions that validate interoperability between Python based SSH signing
// and our Go implementation

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	"github.com/leaf-ai/studio-go-runner/internal/defense"
	"github.com/leaf-ai/studio-go-runner/internal/shell"
	random "github.com/leaf-ai/studio-go-runner/pkg/rand"

	"github.com/davecgh/go-spew/spew"
	"github.com/go-stack/stack"
	"github.com/jjeffery/kv"
	"github.com/rs/xid"
)

func TestSignaturePython(t *testing.T) {
	// Create a new TMPDIR so that we can cleanup
	tmpDir, errGo := ioutil.TempDir("", "")
	if errGo != nil {
		t.Fatal(kv.Wrap(errGo).With("stack", stack.Trace().TrimRuntime()))
	}
	defer func() {
		os.RemoveAll(tmpDir)
	}()

	// Canned data generated using documentation
	privateKey := `-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACAFRJU4Ip9IK6tU/aaVZSBTSfvDcWu+3ckoL3P+iNqL8wAAAKAVmMI2FZjC
NgAAAAtzc2gtZWQyNTUxOQAAACAFRJU4Ip9IK6tU/aaVZSBTSfvDcWu+3ckoL3P+iNqL8w
AAAEA4F4oQ9kxoX2309L1hIv8VXiLXVeGQLFSi21odo5IAvwVElTgin0grq1T9ppVlIFNJ
+8Nxa77dySgvc/6I2ovzAAAAFm1fODExODYyQE1BQ0xUVVMxMDgzMDIBAgMEBQYH
-----END OPENSSH PRIVATE KEY-----
`

	publicKey := `ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAVElTgin0grq1T9ppVlIFNJ+8Nxa77dySgvc/6I2ovz m_811862@MACLTUS108302`

	sigs := GetRqstSigs()
	sigDir := sigs.Dir()

	if len(sigDir) == 0 {
		t.Fatal("signatures directory not ready")
	}

	qName := xid.New().String()

	// Write the public key
	keyFile := filepath.Join(sigDir, qName)
	if errGo = ioutil.WriteFile(keyFile, []byte(publicKey), 0600); errGo != nil {
		t.Fatal(errGo)
	}

	// Now wait for the signature package to signal that the keys
	// have been refreshed and our new file was there
	logger.Debug("waiting for the signature refresh", "stack", stack.Trace().TrimRuntime())
	<-sigs.GetRefresh().Done()
	logger.Debug("done for the signature refresh", "stack", stack.Trace().TrimRuntime())

	// Create a large random payload for signing
	payload := random.RandomString(16 * 1024)

	// Write test data into the temporary directory that will be used
	// by the python code when it runs an ssh paramiko test
	if errGo := ioutil.WriteFile(filepath.Join(tmpDir, "payload"), []byte(payload), 0600); errGo != nil {
		t.Fatal(errGo)
	}

	if errGo := ioutil.WriteFile(filepath.Join(tmpDir, "private"), []byte(privateKey), 0600); errGo != nil {
		t.Fatal(errGo)
	}

	// Grab known files from the crypto test library and place them into
	// our temporary test directory
	testFiles := map[string]os.FileMode{
		filepath.Join("..", "..", "assets", "crypto", "signer.py"): 0600,
		filepath.Join("..", "..", "assets", "crypto", "signer.sh"): 0700,
	}
	resultsFn := filepath.Join(tmpDir, "signature")

	logger.Debug("starting the python test code", "results", resultsFn, "stack", stack.Trace().TrimRuntime())

	output, err := shell.PythonRun(testFiles, tmpDir, filepath.Join(tmpDir, "signer.sh"), 1024)
	if err != nil {
		fmt.Println(output)
		t.Fatal(err)
	}

	logger.Debug("completed the python test code", "results", resultsFn, "stack", stack.Trace().TrimRuntime())

	// Retrieve the signature generated by the python code from the
	// output file it is using
	content, errGo := ioutil.ReadFile(resultsFn)
	if errGo != nil {
		fmt.Println(output)
		t.Fatal(errGo)
	}

	// Data saved in the python code was binary encoded as Base64
	sigBin, errGo := base64.StdEncoding.DecodeString(string(content))
	if errGo != nil {
		t.Fatal(errGo)
	}

	logger.Debug("Parse signature", "sigBin", spew.Sdump(sigBin), "envelope Sig", string(content), "payload", spew.Sdump([]byte(payload[:32])))
	// Converts the signature from the RFC binary L,V format
	sig, err := defense.ParseSSHSignature(sigBin)
	if err != nil {
		t.Fatal(err)
	}
	logger.Debug("Parse signature", "sig", spew.Sdump(sig))

	// Now select from the queue and retrieve the public key
	pubKey, _, err := sigs.SelectSSH(qName)
	if err != nil {
		t.Fatal(err)
	}
	if errGo := pubKey.Verify([]byte(payload), sig); errGo != nil {
		t.Fatal(errGo)
	}
}
